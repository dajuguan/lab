总结这个repo的架构设计，分为如下几个部分。

# 为什么要做架构？
因为系统会变化，而变化会产生复杂度。 架构的目的是控制复杂度增长速度。如果不做架构， 规则会散落在各地，修改一个地方就波及全局。架构就是为了阻止这种“变化扩散”。
架构的本质不是组织代码，而是**隔离变化**。架构的终极目标：让变化局部化，让复杂性被封装，给系统建立稳定的“认知边界”。
顶级架构师不先看函数和调用图，而是先看不变量、变化来源、责任边界

# 架构设计基本步骤
## 需求分析
- 对问题刨根究底，找到根源需求
- 对需求进行归纳整理
    - 将需求归类到不同的类别中
    - 形成需求的变化点和稳定点的基本判断

## 概要设计
概要设计的核心目标是将**系统正交分解为子系统并串联起整个系统**，消除系统的重大风险，最好有代码产出，以验证原型和接口设计是否合理。
- 确定子系统需要保证什么规则，具备什么能力
    - 能力不是“它能做什么”，，而是“它必须保证什么”，保证什么 = 不变量 = 责任。
- 确定哪些是稳定的，哪些是变化以及变化波及的范围
- 根据上述分析，确定子系统的边界，并定义相应的核心规格(包括公开暴露的结构体、接口等)

### 分解方法论（核心纵向 + 外围横向）

在 [`commonware.consensus`](./commonware.md) 的分析中，可以提炼一条可复用的方法论：先识别“语义复杂核心”，再按数据流分离外围系统。

#### 两类系统

1. 核心系统（Core System）  
语义复杂、状态耦合高、正确性负担重，通常包含协议状态机和安全活性约束。  
在 `consensus` 中，`simplex` 属于这一类。
2. 辅助系统（Peripheral Systems）  
围绕核心系统提供输入适配、结果整形、观测、回填、存储对齐等能力。  
在 `consensus` 中，`application::Marshaled` 与 `marshal` 属于这一类。

#### 两种分解方式

1. 纵向分解（主链）  
按业务顺序和数据流串联输入 -> 核心处理 -> 输出整形。  
`consensus` 主链是：`Application -> Marshaled -> simplex -> marshal -> Application(report)`。
- 如果是事件驱动或者Actor模型，需要把对应的消息链路和接口也描述出来
2. 横向分解（旁路）  
把与主链并列但不嵌入主状态机的能力单独建模。  
`aggregation`、`ordered_broadcast` 属于并列旁路协议原语。

#### 判定准则

1. 是否承载协议安全/活性不变量：是则归核心系统。
2. 是否主要做接口转换、数据整形、回填、观测：是则归辅助系统。
3. 是否不进入主状态机闭环：是则优先按横向并列拆分。
4. 是否可独立替换而不改变核心协议语义：可则应独立成外围模块。

#### 工程收益

1. 降低认知复杂度：核心逻辑与工程配套逻辑分治。
2. 降低变更风险：核心协议不变量集中，外围可独立演进。
3. 提升测试清晰度：核心做协议正确性测试，外围做数据流与恢复语义测试。
4. 提升扩展性：新增旁路协议或新适配层时，不必侵入核心状态机。

## 详细设计
- 完备地描述模块的所有接口
    - 不能只画架构图(相当于建筑设计图没标尺寸)，因为架构图不是接口的精确描述，
- 模块的实现原理

# 参考架构review
- [commonware](./commonware.md)
- [tempo](./tempo.md)
- [lighthouse](./lighthouse.md)