# Benchmarking block-level access lists for Geth

## Set up
- Geth full node with PathDB scheme
- BALs with
    1. pre-block account addresses and storage slot keys
    2. post-block tx account and storage values

## Steps to reproduce BAL performance results

### Sync a geth full node first

### Dump historical blocks

```
# Stop the running geth first.
DATADIR="" # your geth --datadir option
# "start": the target block number to rewind in decimal; 
# if latestblock - start > 128, geth's snapshot will be broken, we'll have to wait ~3 hours for snapshot recovery.
geth export  --datadir $DATADIR dump.dat start+1 end 
```

### Rewind to the target block(the above `start` block number)

```
# Start geth first
geth attach $DATADIR/geth.ipc
num="target block number in decimal"
debug.setHead('0x'+(num).toString(16))
``` 

### BAL data generation
The following commands will create a new file `bal_postKV.json` by replaying txs in your current directory.
```
git clone git@github.com:dajuguan/go-ethereum.git
cd go-ethereum && git checkout po/bal 
make geth
# Stop the running geth first
./build/bin/geth --datadir $DATADIR import --nocompaction dump.dat
```

#### Rewind the head to the target block again
```
geth attach $DATADIR/geth.ipc
num="target block number in decimal"
debug.setHead('0x'+(num).toString(16))
``` 

### Geth import with BAL simulating 10X gas limit
> The default `importBatchSize` in `cmd/utils/cmd.go` is 10 blocks, which means we will parallel execute 10 blocks then commit at once. 
> Adjust importBatchSize (must evenly divide total imported blocks) to simulate different gas limits.
```
# Stop the running geth first.
git checkout po/par_exe_nblocks
make geth
./build/bin/geth --metrics --datadir $DATADIR  --cache.noprefetch import --nocompaction dump.dat
```


## 10x Gas limit simulation 

### Design doc
- 4 modes:
    - tag txs with global txIndex: possible but the workload is heavy, because txContext, system opCodes, gasPool and related with block.
    - prefetch all, concurrent(precompute all post state and fetch trie, executing and merge postState from initialDB): merge postState incurs overhead
    - prefetch all, concurrent(precompute all post state and fetch trie, executing and sync poststate for each block): need a way to sync postState
    - prefetch all, for each block concurrent(precompute all post state and fetch trie, executing and merge postState from initialDB)

- implementation checkList
    - prefetch pre-N-blocks state with merged pre-block BALs (take care not overriding previous block's account/storage states)
    - concurrent execution:
        - merge post-N-blocks state with merged post-BALs
        - processBlock with shared statedDB
            - write headers for all blocks
            - for each block:
                - precompute poststate snapshot for this block
                - parallel executing txs in one block
                - validate receipts and gas used
                - don't copy poststate snapshot for this block
                - initialdb used in parallel executing should be minimal to avoid copy cost 

    - validate stateRoot after executing N-blocks
